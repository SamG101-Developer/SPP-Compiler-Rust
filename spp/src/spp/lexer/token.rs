use std::fmt::{Display, Formatter};

#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum TokenType {
    TkCharacter(char),
    TkNumber(char),
    TkEqualsSign,
    TkPlusSign,
    TkMinusSign,
    TkAsterisk,
    TkForwardSlash,
    TkPercentSign,
    TkCaret,
    TkLessThanSign,
    TkGreaterThanSign,
    TkLeftParenthesis,
    TkRightParenthesis,
    TkLeftSquareBracket,
    TkRightSquareBracket,
    TkLeftCurlyBrace,
    TkRightCurlyBrace,
    TkQuestionMark,
    TkColon,
    TkAmpersand,
    TkVerticalBar,
    TkDot,
    TkComma,
    TkAt,
    TkUnderscore,
    TkSpeechMark,
    TkWhitespace,
    TkNewLine,
    TkDollar,
    TkUnknown(char),
    NoToken,
    Keyword,
    EndOfFile,
    TkExclamationMark,
}

impl Display for TokenType {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        let str = match self {
            TokenType::TkCharacter(c) => c.to_string(),
            TokenType::TkNumber(c) => c.to_string(),
            TokenType::TkEqualsSign => "=".to_string(),
            TokenType::TkPlusSign => "+".to_string(),
            TokenType::TkMinusSign => "-".to_string(),
            TokenType::TkAsterisk => "*".to_string(),
            TokenType::TkForwardSlash => "/".to_string(),
            TokenType::TkPercentSign => "%".to_string(),
            TokenType::TkCaret => "^".to_string(),
            TokenType::TkLessThanSign => "<".to_string(),
            TokenType::TkGreaterThanSign => ">".to_string(),
            TokenType::TkLeftParenthesis => "(".to_string(),
            TokenType::TkRightParenthesis => ")".to_string(),
            TokenType::TkLeftSquareBracket => "[".to_string(),
            TokenType::TkRightSquareBracket => "]".to_string(),
            TokenType::TkLeftCurlyBrace => "{".to_string(),
            TokenType::TkRightCurlyBrace => "}".to_string(),
            TokenType::TkQuestionMark => "?".to_string(),
            TokenType::TkColon => ":".to_string(),
            TokenType::TkAmpersand => "&".to_string(),
            TokenType::TkVerticalBar => "|".to_string(),
            TokenType::TkDot => ".".to_string(),
            TokenType::TkComma => ",".to_string(),
            TokenType::TkAt => "@".to_string(),
            TokenType::TkUnderscore => "_".to_string(),
            TokenType::TkSpeechMark => "\"".to_string(),
            TokenType::TkWhitespace => " ".to_string(),
            TokenType::TkNewLine => "\n".to_string(),
            TokenType::TkDollar => "$".to_string(),
            TokenType::TkUnknown(c) => c.to_string(),
            TokenType::NoToken => "".to_string(),
            TokenType::Keyword => "<Kw>".to_string(),
            TokenType::EndOfFile => "<EOF>".to_string(),
            TokenType::TkExclamationMark => "!".to_string(),
        };
        write!(f, "{}", str)
    }
}

pub enum Keywords {
    Cls,
    Fun,
    Cor,
    Sup,
    Ext,
    Mut,
    Use,
    Cmp,
    Let,
    Where,
    SelfVal,
    SelfType,
    Case,
    Of,
    Loop,
    In,
    Else,
    Gen,
    With,
    Ret,
    Exit,
    Skip,
    Pin,
    Rel,
    Is,
    As,
    Or,
    And,
    Not,
    Async,
    Step,
    True,
    False,
}

impl Display for Keywords {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let str = match self {
            Keywords::Cls => "cls".to_string(),
            Keywords::Fun => "fun".to_string(),
            Keywords::Cor => "cor".to_string(),
            Keywords::Sup => "sup".to_string(),
            Keywords::Ext => "ext".to_string(),
            Keywords::Use => "use".to_string(),
            Keywords::Cmp => "cmp".to_string(),
            Keywords::Let => "let".to_string(),
            Keywords::Mut => "mut".to_string(),
            Keywords::Where => "where".to_string(),
            Keywords::SelfVal => "self".to_string(),
            Keywords::SelfType => "Self".to_string(),
            Keywords::Case => "case".to_string(),
            Keywords::Of => "of".to_string(),
            Keywords::Loop => "loop".to_string(),
            Keywords::In => "in".to_string(),
            Keywords::Else => "else".to_string(),
            Keywords::Gen => "gen".to_string(),
            Keywords::With => "with".to_string(),
            Keywords::Ret => "ret".to_string(),
            Keywords::Exit => "exit".to_string(),
            Keywords::Skip => "skip".to_string(),
            Keywords::Pin => "pin".to_string(),
            Keywords::Rel => "rel".to_string(),
            Keywords::Is => "is".to_string(),
            Keywords::As => "as".to_string(),
            Keywords::Or => "or".to_string(),
            Keywords::And => "and".to_string(),
            Keywords::Not => "not".to_string(),
            Keywords::Async => "async".to_string(),
            Keywords::Step => "step".to_string(),
            Keywords::True => "true".to_string(),
            Keywords::False => "false".to_string(),
        };
        write!(f, "{}", str)
    }
}

#[derive(Clone, Debug)]
pub enum TokenAstTokenType {
    LxIdentifier,
    LxUpperIdentifier,
    LxBinDigits,
    LxHexDigits,
    LxDecInteger,
    LxDoubleQuoteStr,
    LxMultiLineComment,
    LxSingleLineComment,

    KwCls,
    KwSup,
    KwFun,
    KwCor,
    KwUse,
    KwExt,
    KwCmp,
    KwLet,
    KwMut,
    KwPin,
    KwRel,
    KwCase,
    KwElse,
    KwLoop,
    KwWith,
    KwSkip,
    KwExit,
    KwStep,
    KwRet,
    KwGen,
    KwWhere,
    KwAs,
    KwIsNot,
    KwIs,
    KwTrue,
    KwFalse,
    KwSelfVal,
    KwSelfType,
    KwAnd,
    KwOr,
    KwNot,
    KwOf,
    KwIn,
    KwAsync,

    TkNumber,
    TkString,
    TkEquals,
    TkNotEquals,
    TkLessThanOrEqualSign,
    TkGreaterThanOrEqualSign,
    TkLessThanSign,
    TkGreaterThanSign,
    TkSpaceshipSign,
    TkPlusSign,
    TkMinusSign,
    TkAsterisk,
    TkForwardSlash,
    TkPercentSign,
    TkDoublePercentSign,
    TkExponentSign,
    TkPlusEqualsSign,
    TkMinusEqualsSign,
    TkAsteriskEqualsSign,
    TkForwardSlashEqualsSign,
    TkPercentEqualsSign,
    TkDoublePercentEqualsSign,
    TkExponentEqualsSign,
    TkLeftParenthesis,
    TkRightParenthesis,
    TkLeftSquareBracket,
    TkRightSquareBracket,
    TkLeftCurlyBrace,
    TkRightCurlyBrace,
    TkQuestionMark,
    TkDoubleDot,
    TkColon,
    TkAmpersand,
    TkVerticalBar,
    TkDot,
    TkDoubleColon,
    TkComma,
    TkAssign,
    TkRightwardsArrow,
    TkAt,
    TkSpeechMark,
    TkUnderscore,
    TkWhitespace,
    TkNewLine,
    TkDollar,

    NoToken,
    EndOfFile,
}

pub type TokenStream = Vec<TokenType>;
